{"version":3,"sources":["../../../src/raydium/liquidity/stable.ts","../../../src/marshmallow/index.ts","../../../src/marshmallow/buffer-layout.ts"],"sourcesContent":["import { Connection, PublicKey } from \"@solana/web3.js\";\n\nimport { seq, struct, u64 } from \"@/marshmallow\";\n\nexport const MODEL_DATA_PUBKEY = new PublicKey(\"CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo\");\nconst ELEMENT_SIZE = 50000;\n\nexport const DataElement = struct([u64(\"x\"), u64(\"y\"), u64(\"price\")]);\n\nexport const modelDataInfoLayout = struct([\n  u64(\"accountType\"),\n  u64(\"status\"),\n  u64(\"multiplier\"),\n  u64(\"validDataCount\"),\n  seq(DataElement, ELEMENT_SIZE, \"DataElement\"),\n]);\n\nexport interface StableModelLayout {\n  accountType: number;\n  status: number;\n  multiplier: number;\n  validDataCount: number;\n  DataElement: { x: number; y: number; price: number }[];\n}\n\nfunction estimateRangeByXyReal(_xReal: number, _yReal: number): number[] {\n  return [0, ELEMENT_SIZE - 2];\n}\n\nfunction estimateRangeByX(_x: number): number[] {\n  return [0, ELEMENT_SIZE - 2];\n}\n\nfunction estimateRangeByY(_y: number): number[] {\n  return [0, ELEMENT_SIZE - 2];\n}\n\nfunction getMininumRangeByXyReal(\n  layoutData: StableModelLayout,\n  xReal: number,\n  yReal: number,\n): [number, number, boolean] {\n  const [min, max] = estimateRangeByXyReal(xReal, yReal);\n  let minRangeIdx = min;\n  let maxRangeIdx = max;\n  let mid = 0;\n  const target = (xReal * layoutData.multiplier) / yReal;\n  while (minRangeIdx <= maxRangeIdx) {\n    mid = Math.floor((maxRangeIdx + minRangeIdx) / 2);\n    if (mid === 0 || mid >= ELEMENT_SIZE - 2) {\n      return [mid, mid, false];\n    }\n    const cur = (layoutData.DataElement[mid].x * layoutData.multiplier) / layoutData.DataElement[mid].y;\n    const left = (layoutData.DataElement[mid - 1].x * layoutData.multiplier) / layoutData.DataElement[mid - 1].y;\n    const right = (layoutData.DataElement[mid + 1].x * layoutData.multiplier) / layoutData.DataElement[mid + 1].y;\n\n    if (target === cur) {\n      return [mid, mid, true];\n    } else if (target === left) {\n      return [mid - 1, mid - 1, true];\n    } else if (target === right) {\n      return [mid + 1, mid + 1, true];\n    } else if (target < left) {\n      maxRangeIdx = mid - 1;\n    } else if (target > left && target < cur) {\n      return [mid - 1, mid, true];\n    } else if (target > cur && target < right) {\n      return [mid, mid + 1, true];\n    } else {\n      minRangeIdx = mid + 1;\n    }\n  }\n  return [mid, mid, false];\n}\nfunction getRatio(layoutData: StableModelLayout, xReal: number, yReal: number): number {\n  const [minRangeIdx, maxRangeIdx, find] = getMininumRangeByXyReal(layoutData, xReal, yReal);\n\n  if (!find) {\n    return 0;\n  }\n\n  if (minRangeIdx === maxRangeIdx) {\n    const x = layoutData.DataElement[minRangeIdx].x;\n    const ratio = (xReal * layoutData.multiplier) / x;\n    return ratio;\n  } else {\n    const x1 = layoutData.DataElement[minRangeIdx].x;\n    const y1 = layoutData.DataElement[minRangeIdx].y;\n    const x2 = layoutData.DataElement[maxRangeIdx].x;\n    const y2 = layoutData.DataElement[maxRangeIdx].y;\n\n    const xDenominator = yReal * (x2 * y1 - x1 * y2);\n    const xNumerator1 = x1 * xDenominator;\n    const xNumerator2 = (x2 - x1) * (xReal * y1 - x1 * yReal) * y2;\n\n    const xNumerator = xNumerator1 + xNumerator2;\n    const ratio = (xReal * layoutData.multiplier * xDenominator) / xNumerator;\n    return ratio;\n  }\n}\n\nfunction realToTable(layoutData: StableModelLayout, realValue: number, ratio: number): number {\n  return (realValue * layoutData.multiplier) / ratio;\n}\n\nfunction tableToReal(layoutData: StableModelLayout, tableValue: number, ratio: number): number {\n  return (tableValue * ratio) / layoutData.multiplier;\n}\n\nfunction getMinimumRangeByX(layoutData: StableModelLayout, x: number): [number, number, boolean] {\n  const [min, max] = estimateRangeByX(x);\n  let minRangeIdx = min;\n  let maxRangeIdx = max;\n  let mid = 0;\n  const target = x;\n  while (minRangeIdx < maxRangeIdx) {\n    mid = Math.floor((maxRangeIdx + minRangeIdx) / 2);\n\n    if (mid <= 0 || mid > ELEMENT_SIZE - 2) {\n      return [mid, mid, false];\n    }\n    const cur = layoutData.DataElement[mid].x;\n    const left = layoutData.DataElement[mid - 1].x;\n    const right = layoutData.DataElement[mid + 1].x;\n\n    if (target === cur) return [mid, mid, true];\n    else if (target === left) return [mid - 1, mid - 1, true];\n    else if (target === right) return [mid + 1, mid + 1, true];\n    else if (target < left) maxRangeIdx = mid - 1;\n    else if (target > left && target < cur) return [mid - 1, mid, true];\n    else if (target > cur && target < right) return [mid, mid + 1, true];\n    else minRangeIdx = mid + 1;\n  }\n  return [mid, mid, false];\n}\n\nfunction getMinimumRangeByY(layoutData: StableModelLayout, y: number): [number, number, boolean] {\n  const [min, max] = estimateRangeByY(y);\n  let minRangeIdx = min;\n  let maxRangeIdx = max;\n  let mid = 0;\n  const target = y;\n  while (minRangeIdx <= maxRangeIdx) {\n    mid = Math.floor((maxRangeIdx + minRangeIdx) / 2);\n    if (mid <= 0 || mid >= ELEMENT_SIZE - 2) {\n      return [mid, mid, false];\n    }\n\n    const cur = layoutData.DataElement[mid].y;\n    const left = layoutData.DataElement[mid - 1].y;\n    const right = layoutData.DataElement[mid + 1].y;\n    if (target === cur) return [mid, mid, true];\n    else if (target === left) return [mid - 1, mid - 1, true];\n    else if (target === right) return [mid + 1, mid + 1, true];\n    else if (target < right) {\n      minRangeIdx = mid + 1;\n    } else if (target < left && target > cur) return [mid - 1, mid, true];\n    else if (target < cur && target > right) return [mid, mid + 1, true];\n    else maxRangeIdx = mid - 1;\n  }\n  return [mid, mid, false];\n}\n\nfunction getDataByX(\n  layoutData: StableModelLayout,\n  x: number,\n  dx: number,\n  priceUp: boolean,\n): [number, number, boolean, boolean] {\n  const xWithDx = priceUp ? x + dx : x - dx;\n  const [minIdx, maxIdx, find] = getMinimumRangeByX(layoutData, xWithDx);\n  if (!find) return [0, 0, false, find];\n\n  if (minIdx === maxIdx) return [layoutData.DataElement[maxIdx].price, layoutData.DataElement[maxIdx].y, false, find];\n  else {\n    const x1 = layoutData.DataElement[minIdx].x;\n    const x2 = layoutData.DataElement[maxIdx].x;\n    const p1 = layoutData.DataElement[minIdx].price;\n    const p2 = layoutData.DataElement[maxIdx].price;\n    const y1 = layoutData.DataElement[minIdx].y;\n    const y2 = layoutData.DataElement[maxIdx].y;\n\n    if (x >= x1 && x <= x2) {\n      if (priceUp) return [p2, y2, true, find];\n      else return [p1, y1, true, find];\n    } else {\n      let p, y;\n      if (priceUp) {\n        p = p1 + ((p2 - p1) * (x - x1)) / (x2 - x1);\n        y = y1 - ((xWithDx - x1) * layoutData.multiplier) / p2;\n      } else {\n        p = p1 + ((p2 - p1) * (x - x1)) / (x2 - x1);\n        y = y2 + ((x2 - xWithDx) * layoutData.multiplier) / p1;\n      }\n      return [p, y, false, find];\n    }\n  }\n}\n\nfunction getDataByY(\n  layoutData: StableModelLayout,\n  y: number,\n  dy: number,\n  priceUp: boolean,\n): [number, number, boolean, boolean] {\n  const yWithDy = priceUp ? y - dy : y + dy;\n  const [minIdx, maxIdx, find] = getMinimumRangeByY(layoutData, yWithDy);\n  if (!find) return [0, 0, false, find];\n  if (minIdx === maxIdx) return [layoutData.DataElement[maxIdx].price, layoutData.DataElement[maxIdx].x, false, find];\n  else {\n    const x1 = layoutData.DataElement[minIdx].x;\n    const x2 = layoutData.DataElement[maxIdx].x;\n    const p1 = layoutData.DataElement[minIdx].price;\n    const p2 = layoutData.DataElement[maxIdx].price;\n    const y1 = layoutData.DataElement[minIdx].y;\n    const y2 = layoutData.DataElement[maxIdx].y;\n\n    if (y >= y2 && y <= y1) {\n      return priceUp ? [p2, x2, true, find] : [p1, x1, true, find];\n    } else {\n      let p, x;\n      if (priceUp) {\n        p = p1 + ((p2 - p1) * (y1 - y)) / (y1 - y2);\n        x = x1 + (p2 * (y1 - yWithDy)) / layoutData.multiplier;\n      } else {\n        p = p1 + ((p2 - p1) * (y1 - y)) / (y1 - y2);\n        x = x2 - (p1 * (yWithDy - y2)) / layoutData.multiplier;\n      }\n      return [p, x, false, find];\n    }\n  }\n}\n\nfunction getMidPrice(layoutData: StableModelLayout, x: number): number {\n  const ret = getDataByX(layoutData, x, 0, false);\n  if (ret[3]) return ret[0];\n  else return 0;\n}\n\nexport function getDyByDxBaseIn(layoutData: StableModelLayout, xReal: number, yReal: number, dxReal: number): number {\n  const ratio = getRatio(layoutData, xReal, yReal);\n  const x = realToTable(layoutData, xReal, ratio);\n  const y = realToTable(layoutData, yReal, ratio);\n  const dx = realToTable(layoutData, dxReal, ratio);\n  const priceUp = true;\n  const [p, y2, lessTrade, find] = getDataByX(layoutData, x, dx, priceUp);\n  if (!find) return 0;\n  if (lessTrade) {\n    const dyReal = (dxReal * layoutData.multiplier) / p;\n    return dyReal;\n  } else {\n    const dy = y - y2;\n    const dyReal = tableToReal(layoutData, dy, ratio);\n    return dyReal;\n  }\n}\n\nexport function getDxByDyBaseIn(layoutData: StableModelLayout, xReal: number, yReal: number, dyReal: number): number {\n  const ratio = getRatio(layoutData, xReal, yReal);\n  const x = realToTable(layoutData, xReal, ratio);\n  const y = realToTable(layoutData, yReal, ratio);\n  const dy = realToTable(layoutData, dyReal, ratio);\n  const priceUp = false;\n  const [p, x2, lessTrade, find] = getDataByY(layoutData, y, dy, priceUp);\n  if (!find) return 0;\n  if (lessTrade) {\n    const dxReal = (dyReal * p) / layoutData.multiplier;\n    return dxReal;\n  } else {\n    const dx = x - x2;\n    const dxReal = tableToReal(layoutData, dx, ratio);\n    return dxReal;\n  }\n}\n\nexport function formatLayout(buffer: Buffer): StableModelLayout {\n  const layoutInfo = modelDataInfoLayout.decode(buffer);\n  return {\n    accountType: layoutInfo.accountType.toNumber(),\n    status: layoutInfo.status.toNumber(),\n    multiplier: layoutInfo.multiplier.toNumber(),\n    validDataCount: layoutInfo.validDataCount.toNumber(),\n    DataElement: layoutInfo.DataElement.map((item: any) => ({\n      x: item.x.toNumber(),\n      y: item.y.toNumber(),\n      price: item.price.toNumber(),\n    })),\n  };\n}\n\nexport function getStablePrice(\n  layoutData: StableModelLayout,\n  coinReal: number,\n  pcReal: number,\n  baseCoin: boolean,\n): number {\n  const price =\n    getMidPrice(layoutData, realToTable(layoutData, coinReal, getRatio(layoutData, coinReal, pcReal))) /\n    layoutData.multiplier;\n  return baseCoin ? price : 1 / price;\n}\n\nexport class StableLayout {\n  private readonly connection: Connection;\n  private _layoutData: StableModelLayout = {\n    accountType: 0,\n    status: 0,\n    multiplier: 0,\n    validDataCount: 0,\n    DataElement: [],\n  };\n\n  constructor({ connection }: { connection: Connection }) {\n    this.connection = connection;\n  }\n\n  get stableModelData(): StableModelLayout {\n    return this._layoutData;\n  }\n\n  public async initStableModelLayout(): Promise<void> {\n    if (this._layoutData.validDataCount === 0) {\n      if (this.connection) {\n        const acc = await this.connection.getAccountInfo(MODEL_DATA_PUBKEY);\n        if (acc) this._layoutData = formatLayout(acc?.data);\n      }\n    }\n  }\n}\n","import { PublicKey } from \"@solana/web3.js\";\nimport BN, { isBN } from \"bn.js\";\n\nimport {\n  bits,\n  blob,\n  Blob,\n  Layout,\n  offset as _offset,\n  seq as _seq,\n  Structure as _Structure,\n  u32 as _u32,\n  u8 as _u8,\n  UInt,\n  union as _union,\n  Union as _Union,\n} from \"./buffer-layout\";\n\nexport * from \"./buffer-layout\";\nexport { blob };\n\nexport class BNLayout<P extends string = \"\"> extends Layout<BN, P> {\n  blob: Layout<Buffer>;\n  signed: boolean;\n\n  constructor(span: number, signed: boolean, property?: P) {\n    //@ts-expect-error type wrong for super()'s type different from extends, but it desn't matter\n    super(span, property);\n    this.blob = blob(span);\n    this.signed = signed;\n  }\n\n  /** @override */\n  decode(b: Buffer, offset = 0): BN {\n    const num = new BN(this.blob.decode(b, offset), 10, \"le\");\n    if (this.signed) {\n      return num.fromTwos(this.span * 8).clone();\n    }\n    return num;\n  }\n\n  /** @override */\n  encode(src: BN, b: Buffer, offset = 0): number {\n    if (typeof src === \"number\") src = new BN(src); // src will pass a number accidently in union\n    if (this.signed) {\n      src = src.toTwos(this.span * 8);\n    }\n    return this.blob.encode(src.toArrayLike(Buffer, \"le\", this.span), b, offset);\n  }\n}\n\nexport class WideBits<P extends string = \"\"> extends Layout<Record<string, boolean>, P> {\n  _lower: any;\n  _upper: any;\n  // TODO: unknown\n  constructor(property?: P) {\n    //@ts-expect-error type wrong for super()'s type different from extends , but it desn't matter\n    super(8, property);\n    this._lower = bits(_u32(), false);\n    this._upper = bits(_u32(), false);\n  }\n\n  addBoolean(property: string): void {\n    if (this._lower.fields.length < 32) {\n      this._lower.addBoolean(property);\n    } else {\n      this._upper.addBoolean(property);\n    }\n  }\n\n  decode(b: Buffer, offset = 0): Record<string, boolean> {\n    const lowerDecoded = this._lower.decode(b, offset);\n    const upperDecoded = this._upper.decode(b, offset + this._lower.span);\n    return { ...lowerDecoded, ...upperDecoded };\n  }\n\n  encode(src: any /* TEMP */, b: Buffer, offset = 0): any {\n    return this._lower.encode(src, b, offset) + this._upper.encode(src, b, offset + this._lower.span);\n  }\n}\n\nexport function u8<P extends string = \"\">(property?: P): UInt<number, P> {\n  return new UInt(1, property);\n}\n\nexport function u32<P extends string = \"\">(property?: P): UInt<number, P> {\n  return new UInt(4, property);\n}\n\nexport function u64<P extends string = \"\">(property?: P): BNLayout<P> {\n  return new BNLayout(8, false, property);\n}\n\nexport function u128<P extends string = \"\">(property?: P): BNLayout<P> {\n  return new BNLayout(16, false, property);\n}\n\nexport function i8<P extends string = \"\">(property?: P): BNLayout<P> {\n  return new BNLayout(1, true, property);\n}\n\nexport function i64<P extends string = \"\">(property?: P): BNLayout<P> {\n  return new BNLayout(8, true, property);\n}\n\nexport function i128<P extends string = \"\">(property?: P): BNLayout<P> {\n  return new BNLayout(16, true, property);\n}\n\nexport class WrappedLayout<T, U, P extends string = \"\"> extends Layout<U, P> {\n  layout: Layout<T>;\n  decoder: (data: T) => U;\n  encoder: (src: U) => T;\n\n  constructor(layout: Layout<T>, decoder: (data: T) => U, encoder: (src: U) => T, property?: P) {\n    //@ts-expect-error type wrong for super()'s type different from extends , but it desn't matter\n    super(layout.span, property);\n    this.layout = layout;\n    this.decoder = decoder;\n    this.encoder = encoder;\n  }\n\n  decode(b: Buffer, offset?: number): U {\n    return this.decoder(this.layout.decode(b, offset));\n  }\n\n  encode(src: U, b: Buffer, offset?: number): number {\n    return this.layout.encode(this.encoder(src), b, offset);\n  }\n\n  getSpan(b: Buffer, offset?: number): number {\n    return this.layout.getSpan(b, offset);\n  }\n}\n\nexport function publicKey<P extends string = \"\">(property?: P): Layout<PublicKey, P> {\n  return new WrappedLayout(\n    blob(32),\n    (b: Buffer) => new PublicKey(b),\n    (key: PublicKey) => key.toBuffer(),\n    property,\n  );\n}\n\nexport class OptionLayout<T, P> extends Layout<T | null, P> {\n  layout: Layout<T>;\n  discriminator: Layout<number>;\n\n  constructor(layout: Layout<T>, property?: P) {\n    //@ts-expect-error type wrong for super()'s type different from extends , but it desn't matter\n    super(-1, property);\n    this.layout = layout;\n    this.discriminator = _u8();\n  }\n\n  encode(src: T | null, b: Buffer, offset = 0): number {\n    if (src === null || src === undefined) {\n      return this.discriminator.encode(0, b, offset);\n    }\n    this.discriminator.encode(1, b, offset);\n    return this.layout.encode(src, b, offset + 1) + 1;\n  }\n\n  decode(b: Buffer, offset = 0): T | null {\n    const discriminator = this.discriminator.decode(b, offset);\n    if (discriminator === 0) {\n      return null;\n    } else if (discriminator === 1) {\n      return this.layout.decode(b, offset + 1);\n    }\n    throw new Error(\"Invalid option \" + this.property);\n  }\n\n  getSpan(b: Buffer, offset = 0): number {\n    const discriminator = this.discriminator.decode(b, offset);\n    if (discriminator === 0) {\n      return 1;\n    } else if (discriminator === 1) {\n      return this.layout.getSpan(b, offset + 1) + 1;\n    }\n    throw new Error(\"Invalid option \" + this.property);\n  }\n}\n\nexport function option<T, P extends string = \"\">(layout: Layout<T>, property?: P): Layout<T | null, P> {\n  return new OptionLayout<T, P>(layout, property);\n}\n\nexport function bool<P extends string = \"\">(property?: P): Layout<boolean, P> {\n  return new WrappedLayout(_u8(), decodeBool, encodeBool, property);\n}\n\nexport function decodeBool(value: number): boolean {\n  if (value === 0) {\n    return false;\n  } else if (value === 1) {\n    return true;\n  }\n  throw new Error(\"Invalid bool: \" + value);\n}\n\nexport function encodeBool(value: boolean): number {\n  return value ? 1 : 0;\n}\n\nexport function vec<T, P extends string = \"\">(elementLayout: Layout<T>, property?: P): Layout<T[], P> {\n  const length = _u32(\"length\");\n  const layout: Layout<{ values: T[] }> = struct([\n    length,\n    seq(elementLayout, _offset(length, -length.span), \"values\"),\n  ]) as any; // Something I don't know\n  return new WrappedLayout(\n    layout,\n    ({ values }) => values,\n    (values) => ({ values }),\n    property,\n  );\n}\n\nexport function tagged<T, P extends string = \"\">(tag: BN, layout: Layout<T>, property?: P): Layout<T, P> {\n  const wrappedLayout: Layout<{ tag: BN; data: T }> = struct([u64(\"tag\"), layout.replicate(\"data\")]) as any; // Something I don't know\n\n  function decodeTag({ tag: receivedTag, data }: { tag: BN; data: T }): T {\n    if (!receivedTag.eq(tag)) {\n      throw new Error(\"Invalid tag, expected: \" + tag.toString(\"hex\") + \", got: \" + receivedTag.toString(\"hex\"));\n    }\n    return data;\n  }\n\n  return new WrappedLayout(wrappedLayout, decodeTag, (data) => ({ tag, data }), property);\n}\n\nexport function vecU8<P extends string = \"\">(property?: P): Layout<Buffer, P> {\n  const length = _u32(\"length\");\n  const layout: Layout<{ data: Buffer }> = struct([length, blob(_offset(length, -length.span), \"data\")]) as any; // Something I don't know\n  return new WrappedLayout(\n    layout,\n    ({ data }) => data,\n    (data) => ({ data }),\n    property,\n  );\n}\n\nexport function str<P extends string = \"\">(property?: P): Layout<string, P> {\n  return new WrappedLayout(\n    vecU8(),\n    (data) => data.toString(\"utf-8\"),\n    (s) => Buffer.from(s, \"utf-8\"),\n    property,\n  );\n}\n\nexport interface EnumLayout<T, P extends string = \"\"> extends Layout<T, P> {\n  registry: Record<string, Layout<any>>;\n}\n\nexport function rustEnum<T, P extends string = \"\">(variants: Layout<any>[], property?: P): EnumLayout<T, P> {\n  const unionLayout = _union(_u8(), property);\n  variants.forEach((variant, index) => unionLayout.addVariant(index, variant, variant.property));\n  return unionLayout as any; // ?why use UnionLayout? This must be a fault\n}\n\nexport function array<T, P extends string = \"\">(\n  elementLayout: Layout<T>,\n  length: number,\n  property?: P,\n): Layout<T[], P> {\n  const layout = struct([seq(elementLayout, length, \"values\")]) as any as Layout<{ values: T[] }>; // Something I don't know\n  return new WrappedLayout(\n    layout,\n    ({ values }) => values,\n    (values) => ({ values }),\n    property,\n  );\n}\n\nexport class Structure<T, P, D> extends _Structure<T, P, D> {\n  /** @override */\n  decode(b: Buffer, offset?: number): D {\n    return super.decode(b, offset);\n  }\n}\n\nexport function struct<T, P extends string = \"\">(\n  fields: T,\n  property?: P,\n  decodePrefixes?: boolean,\n): T extends Layout<infer Value, infer Property>[]\n  ? Structure<\n      Value,\n      P,\n      {\n        [K in Exclude<Extract<Property, string>, \"\">]: Extract<T[number], Layout<any, K>> extends Layout<infer V, any>\n          ? V\n          : any;\n      }\n    >\n  : any {\n  //@ts-expect-error this type is not quite satisfied the define, but, never no need to worry about.\n  return new Structure(fields, property, decodePrefixes);\n}\n\nexport type GetLayoutSchemaFromStructure<T extends Structure<any, any, any>> = T extends Structure<any, any, infer S>\n  ? S\n  : any;\nexport type GetStructureFromLayoutSchema<S> = Structure<any, any, S>;\n\nexport class Union<Schema> extends _Union<Schema> {\n  encodeInstruction(instruction: any): Buffer {\n    const instructionMaxSpan = Math.max(...Object.values(this.registry).map((r) => r.span));\n    const b = Buffer.alloc(instructionMaxSpan);\n    return b.slice(0, this.encode(instruction, b));\n  }\n\n  decodeInstruction(instruction: any): Partial<Schema> {\n    return this.decode(instruction);\n  }\n}\nexport function union<UnionSchema extends { [key: string]: any } = any>(\n  discr: any,\n  defaultLayout?: any,\n  property?: string,\n): Union<UnionSchema> {\n  return new Union(discr, defaultLayout, property);\n}\n\nclass Zeros extends Blob {\n  decode(b: Buffer, offset: number): Buffer {\n    const slice = super.decode(b, offset);\n    if (!slice.every((v) => v === 0)) {\n      throw new Error(\"nonzero padding bytes\");\n    }\n    return slice;\n  }\n}\n\nexport function zeros(length: number): Zeros {\n  return new Zeros(length);\n}\n\nexport function seq<T, P extends string = \"\", AnotherP extends string = \"\">(\n  elementLayout: Layout<T, P>,\n  count: number | BN | Layout<BN | number, P>,\n  property?: AnotherP,\n): Layout<T[], AnotherP> {\n  let parsedCount: number;\n  const superCount =\n    typeof count === \"number\"\n      ? count\n      : isBN(count)\n      ? count.toNumber()\n      : new Proxy(count as unknown as Layout<number> /* pretend to be Layout<number> */, {\n          get(target, property): any {\n            if (!parsedCount) {\n              // get count in targetLayout. note that count may be BN\n              const countProperty = Reflect.get(target, \"count\");\n\n              // let targetLayout's  property:count be a number\n              parsedCount = isBN(countProperty) ? countProperty.toNumber() : countProperty;\n\n              // record the count\n              Reflect.set(target, \"count\", parsedCount);\n            }\n            return Reflect.get(target, property);\n          },\n          set(target, property, value): any {\n            if (property === \"count\") {\n              parsedCount = value;\n            }\n            return Reflect.set(target, property, value);\n          },\n        });\n\n  // @ts-expect-error force type\n  return _seq(elementLayout, superCount, property);\n}\n","import {\n  bits as _bits,\n  BitStructure as _BitStructure,\n  blob as _blob,\n  Blob as _Blob,\n  cstr as _cstr,\n  f32 as _f32,\n  f32be as _f32be,\n  f64 as _f64,\n  f64be as _f64be,\n  greedy as _greedy,\n  Layout as _Layout,\n  ns64 as _ns64,\n  ns64be as _ns64be,\n  nu64 as _nu64,\n  nu64be as _nu64be,\n  offset as _offset,\n  s16 as _s16,\n  s16be as _s16be,\n  s24 as _s24,\n  s24be as _s24be,\n  s32 as _s32,\n  s32be as _s32be,\n  s40 as _s40,\n  s40be as _s40be,\n  s48 as _s48,\n  s48be as _s48be,\n  s8 as _s8,\n  seq as _seq,\n  struct as _struct,\n  Structure as _Structure,\n  u16 as _u16,\n  u16be as _u16be,\n  u24 as _u24,\n  u24be as _u24be,\n  u32 as _u32,\n  u32be as _u32be,\n  u40 as _u40,\n  u40be as _u40be,\n  u48 as _u48,\n  u48be as _u48be,\n  u8 as _u8,\n  UInt as _UInt,\n  union as _union,\n  Union as _Union,\n  unionLayoutDiscriminator as _unionLayoutDiscriminator,\n  utf8 as _utf8,\n} from \"@solana/buffer-layout\";\n\n//#region ------------------- Layout -------------------\nexport interface Layout<T = any, P = \"\"> {\n  span: number;\n  property?: P;\n  decode(b: Buffer, offset?: number): T;\n  encode(src: T, b: Buffer, offset?: number): number;\n  getSpan(b: Buffer, offset?: number): number;\n  replicate<AP extends string>(name: AP): Layout<T, AP>;\n}\nexport interface LayoutConstructor {\n  new <T, P>(): Layout<T, P>; // for class extends syntex\n  new <T, P>(span?: T, property?: P): Layout<T, P>;\n  readonly prototype: Layout;\n}\nexport const Layout = _Layout as unknown as LayoutConstructor;\n//#endregion\n\n//#region ------------------- Structure -------------------\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport interface Structure<T = any, P = \"\", DecodeSchema extends { [key: string]: any } = any>\n  extends Layout<DecodeSchema, P> {\n  span: number;\n  decode(b: Buffer, offset?: number): DecodeSchema;\n  layoutFor<AP extends string>(property: AP): Layout<DecodeSchema[AP]>;\n  offsetOf<AP extends string>(property: AP): number;\n}\ninterface StructureConstructor {\n  new <T = any, P = \"\", DecodeSchema extends { [key: string]: any } = any>(): Structure<T, P, DecodeSchema>;\n  new <T = any, P = \"\", DecodeSchema extends { [key: string]: any } = any>(\n    fields: T,\n    property?: P,\n    decodePrefixes?: boolean,\n  ): Structure<T, P, DecodeSchema>;\n}\nexport const Structure = _Structure as unknown as StructureConstructor;\n//#endregion\n\n//#region ------------------- Union -------------------\nexport interface Union<UnionSchema extends { [key: string]: any } = any> extends Layout {\n  registry: object;\n  decode(b: Buffer, offset?: number): Partial<UnionSchema>;\n  addVariant(\n    variant: number,\n    layout: Structure<any, any, Partial<UnionSchema>> | Layout<any, keyof UnionSchema>,\n    property?: string,\n  ): any /* TEMP: code in Layout.js 1809 */;\n}\ninterface UnionConstructor {\n  new <UnionSchema extends { [key: string]: any } = any>(): Union<UnionSchema>;\n  new <UnionSchema extends { [key: string]: any } = any>(\n    discr: Layout<any, any>,\n    defaultLayout: Layout<any, any>,\n    property?: string,\n  ): Union<UnionSchema>;\n}\nexport const Union = _Union as unknown as UnionConstructor;\n//#endregion\n\n//#region ------------------- BitStructure -------------------\nexport type BitStructure<T = unknown /* TEMP */, P = \"\"> = Layout<T, P>;\ninterface BitStructureConstructor {\n  new (...params: any[]): BitStructure;\n}\nexport const BitStructure = _BitStructure as BitStructureConstructor;\n//#endregion\n\n//#region ------------------- UInt -------------------\nexport type UInt<T = any, P = \"\"> = Layout<T, P>;\ninterface UIntConstructor {\n  new <T, P>(span?: T, property?: P): UInt<T, P>;\n}\nexport const UInt = _UInt as UIntConstructor;\n//#endregion\n\n//#region ------------------- Blob -------------------\nexport type Blob<P extends string = \"\"> = Layout<Buffer, P>;\ninterface BlobConstructor {\n  new (...params: ConstructorParameters<LayoutConstructor>): Blob;\n}\nexport const Blob = _Blob as unknown as BlobConstructor;\n//#endregion\n\nexport const greedy = _greedy as <P extends string = \"\">(elementSpan?: number, property?: P) => Layout<number, P>;\nexport const u8 = _u8 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u16 = _u16 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u24 = _u24 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u32 = _u32 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u40 = _u40 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u48 = _u48 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const nu64 = _nu64 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u16be = _u16be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u24be = _u24be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u32be = _u32be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u40be = _u40be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u48be = _u48be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const nu64be = _nu64be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s8 = _s8 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s16 = _s16 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s24 = _s24 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s32 = _s32 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s40 = _s40 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s48 = _s48 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const ns64 = _ns64 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s16be = _s16be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s24be = _s24be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s32be = _s32be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s40be = _s40be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s48be = _s48be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const ns64be = _ns64be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const f32 = _f32 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const f32be = _f32be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const f64 = _f64 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const f64be = _f64be as <P extends string = \"\">(property?: P) => Layout<number, P>;\n\nexport const struct = _struct as <T, P extends string = \"\">(\n  fields: T,\n  property?: P,\n  decodePrefixes?: boolean,\n) => T extends Layout<infer Value, infer Property>[]\n  ? Structure<\n      Value,\n      P,\n      {\n        [K in Exclude<Extract<Property, string>, \"\">]: Extract<T[number], Layout<any, K>> extends Layout<infer V, any>\n          ? V\n          : any;\n      }\n    >\n  : any;\n\nexport const seq = _seq as unknown as <T, P>(\n  elementLayout: Layout<T, string>,\n  count: number | Layout<number, string>,\n  property?: P,\n) => Layout<T[]>;\nexport const union = _union as <UnionSchema extends { [key: string]: any } = any>(\n  discr: Layout<any, any>,\n  defaultLayout?: any,\n  property?: string,\n) => Union<UnionSchema>;\nexport const unionLayoutDiscriminator = _unionLayoutDiscriminator as <P extends string = \"\">(\n  layout: Layout<any, P>,\n  property?: P,\n) => any;\nexport const blob = _blob as unknown as <P extends string = \"\">(\n  length: number | Layout<number, P>,\n  property?: P,\n) => Blob<P>;\nexport const cstr = _cstr as <P extends string = \"\">(property?: P) => Layout<string, P>;\nexport const utf8 = _utf8 as <P extends string = \"\">(maxSpan: number, property?: P) => Layout<string, P>;\nexport const bits = _bits as unknown as <T, P extends string = \"\">(\n  word: Layout<T>,\n  msb?: boolean,\n  property?: P,\n) => BitStructure<T, P>; // TODO: not quite sure\nexport const offset = _offset as unknown as <T, P extends string = \"\">(\n  layout: Layout<T, P>,\n  offset?: number,\n  property?: P,\n) => Layout<T, P>;\n\nexport type GetStructureSchema<T extends Structure> = T extends Structure<any, any, infer S> ? S : unknown;\n"],"mappings":"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","names":["PublicKey","PublicKey","BN","isBN","_bits","_BitStructure","_blob","_Blob","_cstr","_f32","_f32be","_f64","_f64be","_greedy","_Layout","_ns64","_ns64be","_nu64","_nu64be","_offset","_s16","_s16be","_s24","_s24be","_s32","_s32be","_s40","_s40be","_s48","_s48be","_s8","_seq","_struct","_Structure","_u16","_u16be","_u24","_u24be","_u32","_u32be","_u40","_u40be","_u48","_u48be","_u8","_UInt","_union","_Union","_unionLayoutDiscriminator","_utf8","Layout","Structure","seq","_seq","blob","_blob","BNLayout","Layout","span","signed","property","blob","b","offset","num","BN","src","u64","property","BNLayout","Structure","b","offset","struct","fields","property","decodePrefixes","seq","elementLayout","count","property","parsedCount","superCount","isBN","target","countProperty","value","MODEL_DATA_PUBKEY","PublicKey","ELEMENT_SIZE","DataElement","struct","u64","modelDataInfoLayout","seq","estimateRangeByXyReal","_xReal","_yReal","estimateRangeByX","_x","estimateRangeByY","_y","getMininumRangeByXyReal","layoutData","xReal","yReal","min","max","minRangeIdx","maxRangeIdx","mid","target","cur","left","right","getRatio","find","x","x1","y1","x2","y2","xDenominator","xNumerator1","xNumerator2","xNumerator","realToTable","realValue","ratio","tableToReal","tableValue","getMinimumRangeByX","getMinimumRangeByY","y","getDataByX","dx","priceUp","xWithDx","minIdx","maxIdx","p1","p2","p","getDataByY","dy","yWithDy","getMidPrice","ret","getDyByDxBaseIn","dxReal","lessTrade","getDxByDyBaseIn","dyReal","formatLayout","buffer","layoutInfo","item","getStablePrice","coinReal","pcReal","baseCoin","price","StableLayout","connection","acc"]}
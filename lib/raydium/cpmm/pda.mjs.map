{"version":3,"sources":["../../../src/common/txTool/txUtils.ts","../../../src/common/logger.ts","../../../src/raydium/cpmm/pda.ts"],"sourcesContent":["import {\n  Connection,\n  PublicKey,\n  ComputeBudgetProgram,\n  SimulatedTransactionResponse,\n  Transaction,\n  TransactionInstruction,\n  TransactionMessage,\n  Keypair,\n  EpochInfo,\n  VersionedTransaction,\n} from \"@solana/web3.js\";\nimport { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\n\nimport { createLogger } from \"../logger\";\nimport { InstructionType } from \"./txType\";\nimport { CacheLTA } from \"./lookupTable\";\n\nimport { ComputeBudgetConfig } from \"@/raydium/type\";\n\nconst logger = createLogger(\"Raydium_txUtil\");\n\nexport const MAX_BASE64_SIZE = 1644;\n\nexport function addComputeBudget(config: ComputeBudgetConfig): {\n  instructions: TransactionInstruction[];\n  instructionTypes: string[];\n} {\n  const ins: TransactionInstruction[] = [];\n  const insTypes: string[] = [];\n  if (config.microLamports) {\n    ins.push(ComputeBudgetProgram.setComputeUnitPrice({ microLamports: config.microLamports }));\n    insTypes.push(InstructionType.SetComputeUnitPrice);\n  }\n  if (config.units) {\n    ins.push(ComputeBudgetProgram.setComputeUnitLimit({ units: config.units }));\n    insTypes.push(InstructionType.SetComputeUnitLimit);\n  }\n\n  return {\n    instructions: ins,\n    instructionTypes: insTypes,\n  };\n}\n\nexport async function getRecentBlockHash(connection: Connection): Promise<string> {\n  try {\n    return (await connection.getLatestBlockhash?.())?.blockhash || (await connection.getRecentBlockhash()).blockhash;\n  } catch {\n    return (await connection.getRecentBlockhash()).blockhash;\n  }\n}\n\n/**\n * Forecast transaction size\n */\nexport function forecastTransactionSize(instructions: TransactionInstruction[], signers: PublicKey[]): boolean {\n  if (instructions.length < 1) logger.logWithError(`no instructions provided: ${instructions.toString()}`);\n  if (signers.length < 1) logger.logWithError(`no signers provided:, ${signers.toString()}`);\n\n  const transaction = new Transaction();\n  transaction.recentBlockhash = \"11111111111111111111111111111111\";\n  transaction.feePayer = signers[0];\n  transaction.add(...instructions);\n\n  try {\n    return Buffer.from(transaction.serialize({ verifySignatures: false })).toString(\"base64\").length < MAX_BASE64_SIZE;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Simulates multiple instruction\n */\n/**\n * Simulates multiple instruction\n */\nexport async function simulateMultipleInstruction(\n  connection: Connection,\n  instructions: TransactionInstruction[],\n  keyword: string,\n  batchRequest = true,\n): Promise<string[]> {\n  const feePayer = new PublicKey(\"RaydiumSimuLateTransaction11111111111111111\");\n\n  const transactions: Transaction[] = [];\n\n  let transaction = new Transaction();\n  transaction.feePayer = feePayer;\n\n  for (const instruction of instructions) {\n    if (!forecastTransactionSize([...transaction.instructions, instruction], [feePayer])) {\n      transactions.push(transaction);\n      transaction = new Transaction();\n      transaction.feePayer = feePayer;\n    }\n    transaction.add(instruction);\n  }\n  if (transaction.instructions.length > 0) {\n    transactions.push(transaction);\n  }\n\n  let results: SimulatedTransactionResponse[] = [];\n\n  try {\n    results = await simulateTransaction(connection, transactions, batchRequest);\n    if (results.find((i) => i.err !== null)) throw Error(\"rpc simulateTransaction error\");\n  } catch (error) {\n    if (error instanceof Error) {\n      logger.logWithError(\"failed to simulate for instructions\", \"RPC_ERROR\", {\n        message: error.message,\n      });\n    }\n  }\n\n  const logs: string[] = [];\n  for (const result of results) {\n    logger.debug(\"simulate result:\", result);\n\n    if (result.logs) {\n      const filteredLog = result.logs.filter((log) => log && log.includes(keyword));\n      logger.debug(\"filteredLog:\", logs);\n      if (!filteredLog.length) logger.logWithError(\"simulate log not match keyword\", \"keyword\", keyword);\n      logs.push(...filteredLog);\n    }\n  }\n\n  return logs;\n}\n\nexport function parseSimulateLogToJson(log: string, keyword: string): any {\n  const results = log.match(/{[\"\\w:,]+}/g);\n  if (!results || results.length !== 1) {\n    return logger.logWithError(`simulate log fail to match json, keyword: ${keyword}`);\n  }\n\n  return results[0];\n}\n\nexport function parseSimulateValue(log: string, key: string): any {\n  const reg = new RegExp(`\"${key}\":(\\\\d+)`, \"g\");\n\n  const results = reg.exec(log);\n  if (!results || results.length !== 2) {\n    return logger.logWithError(`simulate log fail to match key\", key: ${key}`);\n  }\n\n  return results[1];\n}\n\nexport interface ProgramAddress {\n  publicKey: PublicKey;\n  nonce: number;\n}\nexport function findProgramAddress(\n  seeds: Array<Buffer | Uint8Array>,\n  programId: PublicKey,\n): {\n  publicKey: PublicKey;\n  nonce: number;\n} {\n  const [publicKey, nonce] = PublicKey.findProgramAddressSync(seeds, programId);\n  return { publicKey, nonce };\n}\n\nexport async function simulateTransaction(\n  connection: Connection,\n  transactions: Transaction[],\n  batchRequest?: boolean,\n): Promise<any[]> {\n  let results: any[] = [];\n  if (batchRequest) {\n    const getLatestBlockhash = await connection.getLatestBlockhash();\n\n    const encodedTransactions: string[] = [];\n    for (const transaction of transactions) {\n      transaction.recentBlockhash = getLatestBlockhash.blockhash;\n      transaction.lastValidBlockHeight = getLatestBlockhash.lastValidBlockHeight;\n\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      const message = transaction._compile();\n      const signData = message.serialize();\n\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      const wireTransaction = transaction._serialize(signData);\n      const encodedTransaction = wireTransaction.toString(\"base64\");\n\n      encodedTransactions.push(encodedTransaction);\n    }\n\n    const batch = encodedTransactions.map((keys) => {\n      const args = connection._buildArgs([keys], undefined, \"base64\");\n      return {\n        methodName: \"simulateTransaction\",\n        args,\n      };\n    });\n\n    const reqData: { methodName: string; args: any[] }[][] = [];\n    const itemReqIndex = 20;\n    for (let i = 0; i < Math.ceil(batch.length / itemReqIndex); i++) {\n      reqData.push(batch.slice(i * itemReqIndex, (i + 1) * itemReqIndex));\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    results = await (\n      await Promise.all(\n        reqData.map(async (i) => (await (connection as any)._rpcBatchRequest(i)).map((ii) => ii.result.value)),\n      )\n    ).flat();\n  } else {\n    try {\n      results = await Promise.all(\n        transactions.map(async (transaction) => await (await connection.simulateTransaction(transaction)).value),\n      );\n    } catch (error) {\n      if (error instanceof Error) {\n        logger.logWithError(\"failed to get info for multiple accounts\", \"RPC_ERROR\", {\n          message: error.message,\n        });\n      }\n    }\n  }\n\n  return results;\n}\n\nexport function checkLegacyTxSize({\n  instructions,\n  payer,\n  signers,\n}: {\n  instructions: TransactionInstruction[];\n  payer: PublicKey;\n  signers: PublicKey[];\n}): boolean {\n  return forecastTransactionSize(instructions, [payer, ...signers]);\n}\n\nexport function checkV0TxSize({\n  instructions,\n  payer,\n  lookupTableAddressAccount,\n  recentBlockhash = Keypair.generate().publicKey.toString(),\n}: {\n  instructions: TransactionInstruction[];\n  payer: PublicKey;\n  lookupTableAddressAccount?: CacheLTA;\n  recentBlockhash?: string;\n}): boolean {\n  const transactionMessage = new TransactionMessage({\n    payerKey: payer,\n    recentBlockhash,\n    instructions,\n  });\n\n  const messageV0 = transactionMessage.compileToV0Message(Object.values(lookupTableAddressAccount ?? {}));\n  try {\n    const buildLength = Buffer.from(new VersionedTransaction(messageV0).serialize()).toString(\"base64\").length;\n    return buildLength < MAX_BASE64_SIZE;\n  } catch (error) {\n    return false;\n  }\n}\n\nlet epochInfoCache: { time: number; data?: EpochInfo } = {\n  time: 0,\n  data: undefined,\n};\n\nexport async function getEpochInfo(connection: Connection): Promise<EpochInfo> {\n  if (!epochInfoCache.data || (Date.now() - epochInfoCache.time) / 1000 > 30) {\n    const data = await connection.getEpochInfo();\n    epochInfoCache = {\n      time: Date.now(),\n      data,\n    };\n    return data;\n  } else {\n    return epochInfoCache.data;\n  }\n}\n\nexport const toBuffer = (arr: Buffer | Uint8Array | Array<number>): Buffer => {\n  if (Buffer.isBuffer(arr)) {\n    return arr;\n  } else if (arr instanceof Uint8Array) {\n    return Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n  } else {\n    return Buffer.from(arr);\n  }\n};\n\nexport function printSimulate(transactions: Transaction[] | VersionedTransaction[]): string[] {\n  const allBase64: string[] = [];\n  transactions.forEach((transaction) => {\n    if (transaction instanceof Transaction) {\n      if (!transaction.recentBlockhash) transaction.recentBlockhash = TOKEN_PROGRAM_ID.toBase58();\n      if (!transaction.feePayer) transaction.feePayer = Keypair.generate().publicKey;\n    }\n    let serialized = transaction.serialize({ requireAllSignatures: false, verifySignatures: false });\n    if (transaction instanceof VersionedTransaction) serialized = toBuffer(serialized);\n    const base64 = serialized.toString(\"base64\");\n    allBase64.push(base64);\n  });\n  console.log(\"simulate tx string:\", allBase64);\n\n  return allBase64;\n}\n","import { get, set } from \"lodash\";\nimport dayjs from \"dayjs\";\nimport utc from \"dayjs/plugin/utc\";\ndayjs.extend(utc);\n\nexport type ModuleName = \"Common.Api\";\n\nexport enum LogLevel {\n  Error,\n  Warning,\n  Info,\n  Debug,\n}\nexport class Logger {\n  private logLevel: LogLevel;\n  private name: string;\n  constructor(params: { name: string; logLevel?: LogLevel }) {\n    this.logLevel = params.logLevel !== undefined ? params.logLevel : LogLevel.Error;\n    this.name = params.name;\n  }\n\n  set level(logLevel: LogLevel) {\n    this.logLevel = logLevel;\n  }\n  get time(): string {\n    return dayjs().utc().format(\"YYYY/MM/DD HH:mm:ss UTC\");\n  }\n  get moduleName(): string {\n    return this.name;\n  }\n\n  private isLogLevel(level: LogLevel): boolean {\n    return level <= this.logLevel;\n  }\n\n  public error(...props): Logger {\n    if (!this.isLogLevel(LogLevel.Error)) return this;\n    console.error(this.time, this.name, \"sdk logger error\", ...props);\n    return this;\n  }\n\n  public logWithError(...props): Logger {\n    // this.error(...props)\n    const msg = props.map((arg) => (typeof arg === \"object\" ? JSON.stringify(arg) : arg)).join(\", \");\n    throw new Error(msg);\n  }\n\n  public warning(...props): Logger {\n    if (!this.isLogLevel(LogLevel.Warning)) return this;\n    console.warn(this.time, this.name, \"sdk logger warning\", ...props);\n    return this;\n  }\n\n  public info(...props): Logger {\n    if (!this.isLogLevel(LogLevel.Info)) return this;\n    console.info(this.time, this.name, \"sdk logger info\", ...props);\n    return this;\n  }\n\n  public debug(...props): Logger {\n    if (!this.isLogLevel(LogLevel.Debug)) return this;\n    console.debug(this.time, this.name, \"sdk logger debug\", ...props);\n    return this;\n  }\n}\n\nconst moduleLoggers: { [key in ModuleName]?: Logger } = {};\nconst moduleLevels: { [key in ModuleName]?: LogLevel } = {};\n\nexport function createLogger(moduleName: string): Logger {\n  let logger = get(moduleLoggers, moduleName);\n  if (!logger) {\n    // default level is error\n    const logLevel = get(moduleLevels, moduleName);\n\n    logger = new Logger({ name: moduleName, logLevel });\n    set(moduleLoggers, moduleName, logger);\n  }\n\n  return logger;\n}\n\nexport function setLoggerLevel(moduleName: string, level: LogLevel): void {\n  set(moduleLevels, moduleName, level);\n\n  const logger = get(moduleLoggers, moduleName);\n  if (logger) logger.level = level;\n}\n","import { PublicKey } from \"@solana/web3.js\";\nimport { findProgramAddress } from \"@/common/txTool/txUtils\";\n\nconst AUTH_SEED = Buffer.from(\"vault_and_lp_mint_auth_seed\", \"utf8\");\nconst AMM_CONFIG_SEED = Buffer.from(\"amm_config\", \"utf8\");\nconst POOL_SEED = Buffer.from(\"pool\", \"utf8\");\nconst POOL_LP_MINT_SEED = Buffer.from(\"pool_lp_mint\", \"utf8\");\nconst POOL_VAULT_SEED = Buffer.from(\"pool_vault\", \"utf8\");\nconst OBSERVATION_SEED = Buffer.from(\"observation\", \"utf8\");\n\nexport function getPdaPoolAuthority(programId: PublicKey): {\n  publicKey: PublicKey;\n  nonce: number;\n} {\n  return findProgramAddress([AUTH_SEED], programId);\n}\n\nexport function getCpmmPdaAmmConfigId(\n  programId: PublicKey,\n  index: number,\n): {\n  publicKey: PublicKey;\n  nonce: number;\n} {\n  return findProgramAddress([AMM_CONFIG_SEED, u16ToBytes(index)], programId);\n}\n\nexport function getCpmmPdaPoolId(\n  programId: PublicKey,\n  ammConfigId: PublicKey,\n  mintA: PublicKey,\n  mintB: PublicKey,\n): {\n  publicKey: PublicKey;\n  nonce: number;\n} {\n  return findProgramAddress([POOL_SEED, ammConfigId.toBuffer(), mintA.toBuffer(), mintB.toBuffer()], programId);\n}\n\nexport function getPdaLpMint(\n  programId: PublicKey,\n  poolId: PublicKey,\n): {\n  publicKey: PublicKey;\n  nonce: number;\n} {\n  return findProgramAddress([POOL_LP_MINT_SEED, poolId.toBuffer()], programId);\n}\n\nexport function getPdaVault(\n  programId: PublicKey,\n  poolId: PublicKey,\n  mint: PublicKey,\n): {\n  publicKey: PublicKey;\n  nonce: number;\n} {\n  return findProgramAddress([POOL_VAULT_SEED, poolId.toBuffer(), mint.toBuffer()], programId);\n}\n\nexport function getPdaObservationId(\n  programId: PublicKey,\n  poolId: PublicKey,\n): {\n  publicKey: PublicKey;\n  nonce: number;\n} {\n  return findProgramAddress([OBSERVATION_SEED, poolId.toBuffer()], programId);\n}\n\nfunction u16ToBytes(num: number): Uint8Array {\n  const arr = new ArrayBuffer(2);\n  const view = new DataView(arr);\n  view.setUint16(0, num, false);\n  return new Uint8Array(arr);\n}\n\nexport function getCreatePoolKeys({\n  programId,\n  mintA,\n  mintB,\n}: {\n  programId: PublicKey;\n  mintA: PublicKey;\n  mintB: PublicKey;\n}): {\n  poolId: PublicKey;\n  configId: PublicKey;\n  authority: PublicKey;\n  lpMint: PublicKey;\n  vaultA: PublicKey;\n  vaultB: PublicKey;\n  observationId: PublicKey;\n} {\n  const configId = getCpmmPdaAmmConfigId(programId, 0).publicKey;\n  const authority = getPdaPoolAuthority(programId).publicKey;\n  const poolId = getCpmmPdaPoolId(programId, configId, mintA, mintB).publicKey;\n  const lpMint = getPdaLpMint(programId, poolId).publicKey;\n  const vaultA = getPdaVault(programId, poolId, mintA).publicKey;\n  const vaultB = getPdaVault(programId, poolId, mintB).publicKey;\n  const observationId = getPdaObservationId(programId, poolId).publicKey;\n\n  return {\n    poolId,\n    configId,\n    authority,\n    lpMint,\n    vaultA,\n    vaultB,\n    observationId,\n  };\n}\n"],"mappings":"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","names":["PublicKey","ComputeBudgetProgram","Transaction","TransactionMessage","Keypair","VersionedTransaction","TOKEN_PROGRAM_ID","get","set","dayjs","utc","Logger","params","logLevel","dayjs","level","props","msg","arg","moduleLoggers","moduleLevels","createLogger","moduleName","logger","get","set","logger","createLogger","findProgramAddress","seeds","programId","publicKey","nonce","PublicKey","AUTH_SEED","AMM_CONFIG_SEED","POOL_SEED","POOL_LP_MINT_SEED","POOL_VAULT_SEED","OBSERVATION_SEED","getPdaPoolAuthority","programId","findProgramAddress","getCpmmPdaAmmConfigId","index","u16ToBytes","getCpmmPdaPoolId","ammConfigId","mintA","mintB","getPdaLpMint","poolId","getPdaVault","mint","getPdaObservationId","num","arr","getCreatePoolKeys","configId","authority","lpMint","vaultA","vaultB","observationId"]}
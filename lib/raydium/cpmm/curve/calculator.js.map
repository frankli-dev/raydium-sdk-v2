{"version":3,"sources":["../../../../src/raydium/cpmm/curve/calculator.ts","../../../../src/raydium/cpmm/curve/fee.ts","../../../../src/raydium/cpmm/curve/constantProduct.ts"],"sourcesContent":["import BN from \"bn.js\";\nimport { CpmmFee } from \"./fee\";\nimport { ConstantProductCurve } from \"./constantProduct\";\n\nexport enum RoundDirection {\n  Floor,\n  Ceiling,\n}\n\nexport type SwapWithoutFeesResult = { sourceAmountSwapped: BN; destinationAmountSwapped: BN };\n\nexport type TradingTokenResult = { tokenAmount0: BN; tokenAmount1: BN };\n\nexport type SwapResult = {\n  newSwapSourceAmount: BN;\n  newSwapDestinationAmount: BN;\n  sourceAmountSwapped: BN;\n  destinationAmountSwapped: BN;\n  tradeFee: BN;\n};\n\nexport class CurveCalculator {\n  static validate_supply(tokenAmount0: BN, tokenAmount1: BN): void {\n    if (tokenAmount0.isZero()) throw Error(\"tokenAmount0 is zero\");\n    if (tokenAmount1.isZero()) throw Error(\"tokenAmount1 is zero\");\n  }\n\n  static swap(sourceAmount: BN, swapSourceAmount: BN, swapDestinationAmount: BN, tradeFeeRate: BN): SwapResult {\n    const tradeFee = CpmmFee.tradingFee(sourceAmount, tradeFeeRate);\n\n    const sourceAmountLessFees = sourceAmount.sub(tradeFee);\n\n    const { sourceAmountSwapped, destinationAmountSwapped } = ConstantProductCurve.swapWithoutFees(\n      sourceAmountLessFees,\n      swapSourceAmount,\n      swapDestinationAmount,\n    );\n\n    const _sourceAmountSwapped = sourceAmountSwapped.add(tradeFee);\n    return {\n      newSwapSourceAmount: swapSourceAmount.add(_sourceAmountSwapped),\n      newSwapDestinationAmount: swapDestinationAmount.sub(destinationAmountSwapped),\n      sourceAmountSwapped: _sourceAmountSwapped,\n      destinationAmountSwapped,\n      tradeFee,\n    };\n  }\n}\n","import BN from \"bn.js\";\n\nexport const FEE_RATE_DENOMINATOR_VALUE = new BN(1_000_000);\n\nexport function ceilDiv(tokenAmount: BN, feeNumerator: BN, feeDenominator: BN): BN {\n  return tokenAmount.mul(feeNumerator).add(feeDenominator).sub(new BN(1)).div(feeDenominator);\n}\n\nexport function floorDiv(tokenAmount: BN, feeNumerator: BN, feeDenominator: BN): BN {\n  return tokenAmount.mul(feeNumerator).div(feeDenominator);\n}\n\nexport class CpmmFee {\n  static tradingFee(amount: BN, tradeFeeRate: BN): BN {\n    return ceilDiv(amount, tradeFeeRate, FEE_RATE_DENOMINATOR_VALUE);\n  }\n  static protocolFee(amount: BN, protocolFeeRate: BN): BN {\n    return floorDiv(amount, protocolFeeRate, FEE_RATE_DENOMINATOR_VALUE);\n  }\n  static fundFee(amount: BN, fundFeeRate: BN): BN {\n    return floorDiv(amount, fundFeeRate, FEE_RATE_DENOMINATOR_VALUE);\n  }\n}\n","import BN from \"bn.js\";\nimport { RoundDirection, SwapWithoutFeesResult, TradingTokenResult } from \"./calculator\";\n\nfunction checkedRem(dividend: BN, divisor: BN): BN {\n  if (divisor.isZero()) throw Error(\"divisor is zero\");\n\n  const result = dividend.mod(divisor);\n  return result;\n}\n\nfunction checkedCeilDiv(dividend: BN, rhs: BN): BN[] {\n  if (rhs.isZero()) throw Error(\"rhs is zero\");\n\n  let quotient = dividend.div(rhs);\n\n  if (quotient.isZero()) throw Error(\"quotient is zero\");\n\n  let remainder = checkedRem(dividend, rhs);\n\n  if (remainder.gt(ZERO)) {\n    quotient = quotient.add(new BN(1));\n\n    let rhs = dividend.div(quotient);\n    remainder = checkedRem(dividend, quotient);\n    if (remainder.gt(ZERO)) {\n      rhs = rhs.add(new BN(1));\n    }\n  }\n  return [quotient, rhs];\n}\n\nconst ZERO = new BN(0);\n\nexport class ConstantProductCurve {\n  static swapWithoutFees(sourceAmount: BN, swapSourceAmount: BN, swapDestinationAmount: BN): SwapWithoutFeesResult {\n    const invariant = swapSourceAmount.mul(swapDestinationAmount);\n\n    const newSwapSourceAmount = swapSourceAmount.add(sourceAmount);\n    const [newSwapDestinationAmount, _newSwapSourceAmount] = checkedCeilDiv(invariant, newSwapSourceAmount);\n\n    const sourceAmountSwapped = _newSwapSourceAmount.sub(swapSourceAmount);\n    const destinationAmountSwapped = swapDestinationAmount.sub(newSwapDestinationAmount);\n    if (destinationAmountSwapped.isZero()) throw Error(\"destinationAmountSwapped is zero\");\n\n    return {\n      sourceAmountSwapped,\n      destinationAmountSwapped,\n    };\n  }\n\n  static lpTokensToTradingTokens(\n    lpTokenAmount: BN,\n    lpTokenSupply: BN,\n    swapTokenAmount0: BN,\n    swapTokenAmount1: BN,\n    roundDirection: RoundDirection,\n  ): TradingTokenResult {\n    let tokenAmount0 = lpTokenAmount.mul(swapTokenAmount0).div(lpTokenSupply);\n    let tokenAmount1 = lpTokenAmount.mul(swapTokenAmount1).div(lpTokenSupply);\n\n    if (roundDirection === RoundDirection.Floor) {\n      return { tokenAmount0, tokenAmount1 };\n    } else if (roundDirection === RoundDirection.Ceiling) {\n      const tokenRemainder0 = checkedRem(lpTokenAmount.mul(swapTokenAmount0), lpTokenSupply);\n\n      if (tokenRemainder0.gt(ZERO) && tokenAmount0.gt(ZERO)) {\n        tokenAmount0 = tokenAmount0.add(new BN(1));\n      }\n\n      const token1Remainder = checkedRem(lpTokenAmount.mul(swapTokenAmount1), lpTokenSupply);\n\n      if (token1Remainder.gt(ZERO) && tokenAmount1.gt(ZERO)) {\n        tokenAmount1 = tokenAmount1.add(new BN(1));\n      }\n\n      return { tokenAmount0, tokenAmount1 };\n    }\n    throw Error(\"roundDirection value error\");\n  }\n}\n"],"mappings":"6iBAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,qBAAAE,EAAA,mBAAAC,IAAA,eAAAC,EAAAJ,GCAA,IAAAK,EAAe,oBAEFC,EAA6B,IAAI,EAAAC,QAAG,GAAS,EAEnD,SAASC,EAAQC,EAAiBC,EAAkBC,EAAwB,CACjF,OAAOF,EAAY,IAAIC,CAAY,EAAE,IAAIC,CAAc,EAAE,IAAI,IAAI,EAAAJ,QAAG,CAAC,CAAC,EAAE,IAAII,CAAc,CAC5F,CAEO,SAASC,EAASH,EAAiBC,EAAkBC,EAAwB,CAClF,OAAOF,EAAY,IAAIC,CAAY,EAAE,IAAIC,CAAc,CACzD,CAEO,IAAME,EAAN,KAAc,CACnB,OAAO,WAAWC,EAAYC,EAAsB,CAClD,OAAOP,EAAQM,EAAQC,EAAcT,CAA0B,CACjE,CACA,OAAO,YAAYQ,EAAYE,EAAyB,CACtD,OAAOJ,EAASE,EAAQE,EAAiBV,CAA0B,CACrE,CACA,OAAO,QAAQQ,EAAYG,EAAqB,CAC9C,OAAOL,EAASE,EAAQG,EAAaX,CAA0B,CACjE,CACF,ECtBA,IAAAY,EAAe,oBAGf,SAASC,EAAWC,EAAcC,EAAiB,CACjD,GAAIA,EAAQ,OAAO,EAAG,MAAM,MAAM,iBAAiB,EAGnD,OADeD,EAAS,IAAIC,CAAO,CAErC,CAEA,SAASC,EAAeF,EAAcG,EAAe,CACnD,GAAIA,EAAI,OAAO,EAAG,MAAM,MAAM,aAAa,EAE3C,IAAIC,EAAWJ,EAAS,IAAIG,CAAG,EAE/B,GAAIC,EAAS,OAAO,EAAG,MAAM,MAAM,kBAAkB,EAErD,IAAIC,EAAYN,EAAWC,EAAUG,CAAG,EAExC,GAAIE,EAAU,GAAGC,CAAI,EAAG,CACtBF,EAAWA,EAAS,IAAI,IAAI,EAAAG,QAAG,CAAC,CAAC,EAEjC,IAAIJ,EAAMH,EAAS,IAAII,CAAQ,EAC/BC,EAAYN,EAAWC,EAAUI,CAAQ,EACrCC,EAAU,GAAGC,CAAI,IACnBH,EAAMA,EAAI,IAAI,IAAI,EAAAI,QAAG,CAAC,CAAC,EAE3B,CACA,MAAO,CAACH,EAAUD,CAAG,CACvB,CAEA,IAAMG,EAAO,IAAI,EAAAC,QAAG,CAAC,EAERC,EAAN,KAA2B,CAChC,OAAO,gBAAgBC,EAAkBC,EAAsBC,EAAkD,CAC/G,IAAMC,EAAYF,EAAiB,IAAIC,CAAqB,EAEtDE,EAAsBH,EAAiB,IAAID,CAAY,EACvD,CAACK,EAA0BC,CAAoB,EAAIb,EAAeU,EAAWC,CAAmB,EAEhGG,EAAsBD,EAAqB,IAAIL,CAAgB,EAC/DO,EAA2BN,EAAsB,IAAIG,CAAwB,EACnF,GAAIG,EAAyB,OAAO,EAAG,MAAM,MAAM,kCAAkC,EAErF,MAAO,CACL,oBAAAD,EACA,yBAAAC,CACF,CACF,CAEA,OAAO,wBACLC,EACAC,EACAC,EACAC,EACAC,EACoB,CACpB,IAAIC,EAAeL,EAAc,IAAIE,CAAgB,EAAE,IAAID,CAAa,EACpEK,EAAeN,EAAc,IAAIG,CAAgB,EAAE,IAAIF,CAAa,EAExE,GAAIG,IAAmB,EACrB,MAAO,CAAE,aAAAC,EAAc,aAAAC,CAAa,EAC/B,GAAIF,IAAmB,EAG5B,OAFwBvB,EAAWmB,EAAc,IAAIE,CAAgB,EAAGD,CAAa,EAEjE,GAAGb,CAAI,GAAKiB,EAAa,GAAGjB,CAAI,IAClDiB,EAAeA,EAAa,IAAI,IAAI,EAAAhB,QAAG,CAAC,CAAC,GAGnBR,EAAWmB,EAAc,IAAIG,CAAgB,EAAGF,CAAa,EAEjE,GAAGb,CAAI,GAAKkB,EAAa,GAAGlB,CAAI,IAClDkB,EAAeA,EAAa,IAAI,IAAI,EAAAjB,QAAG,CAAC,CAAC,GAGpC,CAAE,aAAAgB,EAAc,aAAAC,CAAa,EAEtC,MAAM,MAAM,4BAA4B,CAC1C,CACF,EF3EO,IAAKC,OACVA,IAAA,iBACAA,IAAA,qBAFUA,OAAA,IAiBCC,EAAN,KAAsB,CAC3B,OAAO,gBAAgBC,EAAkBC,EAAwB,CAC/D,GAAID,EAAa,OAAO,EAAG,MAAM,MAAM,sBAAsB,EAC7D,GAAIC,EAAa,OAAO,EAAG,MAAM,MAAM,sBAAsB,CAC/D,CAEA,OAAO,KAAKC,EAAkBC,EAAsBC,EAA2BC,EAA8B,CAC3G,IAAMC,EAAWC,EAAQ,WAAWL,EAAcG,CAAY,EAExDG,EAAuBN,EAAa,IAAII,CAAQ,EAEhD,CAAE,oBAAAG,EAAqB,yBAAAC,CAAyB,EAAIC,EAAqB,gBAC7EH,EACAL,EACAC,CACF,EAEMQ,EAAuBH,EAAoB,IAAIH,CAAQ,EAC7D,MAAO,CACL,oBAAqBH,EAAiB,IAAIS,CAAoB,EAC9D,yBAA0BR,EAAsB,IAAIM,CAAwB,EAC5E,oBAAqBE,EACrB,yBAAAF,EACA,SAAAJ,CACF,CACF,CACF","names":["calculator_exports","__export","CurveCalculator","RoundDirection","__toCommonJS","import_bn","FEE_RATE_DENOMINATOR_VALUE","BN","ceilDiv","tokenAmount","feeNumerator","feeDenominator","floorDiv","CpmmFee","amount","tradeFeeRate","protocolFeeRate","fundFeeRate","import_bn","checkedRem","dividend","divisor","checkedCeilDiv","rhs","quotient","remainder","ZERO","BN","ConstantProductCurve","sourceAmount","swapSourceAmount","swapDestinationAmount","invariant","newSwapSourceAmount","newSwapDestinationAmount","_newSwapSourceAmount","sourceAmountSwapped","destinationAmountSwapped","lpTokenAmount","lpTokenSupply","swapTokenAmount0","swapTokenAmount1","roundDirection","tokenAmount0","tokenAmount1","RoundDirection","CurveCalculator","tokenAmount0","tokenAmount1","sourceAmount","swapSourceAmount","swapDestinationAmount","tradeFeeRate","tradeFee","CpmmFee","sourceAmountLessFees","sourceAmountSwapped","destinationAmountSwapped","ConstantProductCurve","_sourceAmountSwapped"]}
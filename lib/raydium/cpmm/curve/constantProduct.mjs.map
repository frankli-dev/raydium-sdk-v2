{"version":3,"sources":["../../../../src/raydium/cpmm/curve/constantProduct.ts","../../../../src/raydium/cpmm/curve/fee.ts"],"sourcesContent":["import BN from \"bn.js\";\nimport { RoundDirection, SwapWithoutFeesResult, TradingTokenResult } from \"./calculator\";\n\nfunction checkedRem(dividend: BN, divisor: BN): BN {\n  if (divisor.isZero()) throw Error(\"divisor is zero\");\n\n  const result = dividend.mod(divisor);\n  return result;\n}\n\nfunction checkedCeilDiv(dividend: BN, rhs: BN): BN[] {\n  if (rhs.isZero()) throw Error(\"rhs is zero\");\n\n  let quotient = dividend.div(rhs);\n\n  if (quotient.isZero()) throw Error(\"quotient is zero\");\n\n  let remainder = checkedRem(dividend, rhs);\n\n  if (remainder.gt(ZERO)) {\n    quotient = quotient.add(new BN(1));\n\n    let rhs = dividend.div(quotient);\n    remainder = checkedRem(dividend, quotient);\n    if (remainder.gt(ZERO)) {\n      rhs = rhs.add(new BN(1));\n    }\n  }\n  return [quotient, rhs];\n}\n\nconst ZERO = new BN(0);\n\nexport class ConstantProductCurve {\n  static swapWithoutFees(sourceAmount: BN, swapSourceAmount: BN, swapDestinationAmount: BN): SwapWithoutFeesResult {\n    const invariant = swapSourceAmount.mul(swapDestinationAmount);\n\n    const newSwapSourceAmount = swapSourceAmount.add(sourceAmount);\n    const [newSwapDestinationAmount, _newSwapSourceAmount] = checkedCeilDiv(invariant, newSwapSourceAmount);\n\n    const sourceAmountSwapped = _newSwapSourceAmount.sub(swapSourceAmount);\n    const destinationAmountSwapped = swapDestinationAmount.sub(newSwapDestinationAmount);\n    if (destinationAmountSwapped.isZero()) throw Error(\"destinationAmountSwapped is zero\");\n\n    return {\n      sourceAmountSwapped,\n      destinationAmountSwapped,\n    };\n  }\n\n  static lpTokensToTradingTokens(\n    lpTokenAmount: BN,\n    lpTokenSupply: BN,\n    swapTokenAmount0: BN,\n    swapTokenAmount1: BN,\n    roundDirection: RoundDirection,\n  ): TradingTokenResult {\n    let tokenAmount0 = lpTokenAmount.mul(swapTokenAmount0).div(lpTokenSupply);\n    let tokenAmount1 = lpTokenAmount.mul(swapTokenAmount1).div(lpTokenSupply);\n\n    if (roundDirection === RoundDirection.Floor) {\n      return { tokenAmount0, tokenAmount1 };\n    } else if (roundDirection === RoundDirection.Ceiling) {\n      const tokenRemainder0 = checkedRem(lpTokenAmount.mul(swapTokenAmount0), lpTokenSupply);\n\n      if (tokenRemainder0.gt(ZERO) && tokenAmount0.gt(ZERO)) {\n        tokenAmount0 = tokenAmount0.add(new BN(1));\n      }\n\n      const token1Remainder = checkedRem(lpTokenAmount.mul(swapTokenAmount1), lpTokenSupply);\n\n      if (token1Remainder.gt(ZERO) && tokenAmount1.gt(ZERO)) {\n        tokenAmount1 = tokenAmount1.add(new BN(1));\n      }\n\n      return { tokenAmount0, tokenAmount1 };\n    }\n    throw Error(\"roundDirection value error\");\n  }\n}\n","import BN from \"bn.js\";\n\nexport const FEE_RATE_DENOMINATOR_VALUE = new BN(1_000_000);\n\nexport function ceilDiv(tokenAmount: BN, feeNumerator: BN, feeDenominator: BN): BN {\n  return tokenAmount.mul(feeNumerator).add(feeDenominator).sub(new BN(1)).div(feeDenominator);\n}\n\nexport function floorDiv(tokenAmount: BN, feeNumerator: BN, feeDenominator: BN): BN {\n  return tokenAmount.mul(feeNumerator).div(feeDenominator);\n}\n\nexport class CpmmFee {\n  static tradingFee(amount: BN, tradeFeeRate: BN): BN {\n    return ceilDiv(amount, tradeFeeRate, FEE_RATE_DENOMINATOR_VALUE);\n  }\n  static protocolFee(amount: BN, protocolFeeRate: BN): BN {\n    return floorDiv(amount, protocolFeeRate, FEE_RATE_DENOMINATOR_VALUE);\n  }\n  static fundFee(amount: BN, fundFeeRate: BN): BN {\n    return floorDiv(amount, fundFeeRate, FEE_RATE_DENOMINATOR_VALUE);\n  }\n}\n"],"mappings":"AAAA,OAAOA,MAAQ,QCAf,OAAOC,MAAQ,QAER,IAAMC,EAA6B,IAAID,EAAG,GAAS,EDC1D,SAASE,EAAWC,EAAcC,EAAiB,CACjD,GAAIA,EAAQ,OAAO,EAAG,MAAM,MAAM,iBAAiB,EAGnD,OADeD,EAAS,IAAIC,CAAO,CAErC,CAEA,SAASC,EAAeF,EAAcG,EAAe,CACnD,GAAIA,EAAI,OAAO,EAAG,MAAM,MAAM,aAAa,EAE3C,IAAIC,EAAWJ,EAAS,IAAIG,CAAG,EAE/B,GAAIC,EAAS,OAAO,EAAG,MAAM,MAAM,kBAAkB,EAErD,IAAIC,EAAYN,EAAWC,EAAUG,CAAG,EAExC,GAAIE,EAAU,GAAGC,CAAI,EAAG,CACtBF,EAAWA,EAAS,IAAI,IAAIG,EAAG,CAAC,CAAC,EAEjC,IAAIJ,EAAMH,EAAS,IAAII,CAAQ,EAC/BC,EAAYN,EAAWC,EAAUI,CAAQ,EACrCC,EAAU,GAAGC,CAAI,IACnBH,EAAMA,EAAI,IAAI,IAAII,EAAG,CAAC,CAAC,EAE3B,CACA,MAAO,CAACH,EAAUD,CAAG,CACvB,CAEA,IAAMG,EAAO,IAAIC,EAAG,CAAC,EAERC,EAAN,KAA2B,CAChC,OAAO,gBAAgBC,EAAkBC,EAAsBC,EAAkD,CAC/G,IAAMC,EAAYF,EAAiB,IAAIC,CAAqB,EAEtDE,EAAsBH,EAAiB,IAAID,CAAY,EACvD,CAACK,EAA0BC,CAAoB,EAAIb,EAAeU,EAAWC,CAAmB,EAEhGG,EAAsBD,EAAqB,IAAIL,CAAgB,EAC/DO,EAA2BN,EAAsB,IAAIG,CAAwB,EACnF,GAAIG,EAAyB,OAAO,EAAG,MAAM,MAAM,kCAAkC,EAErF,MAAO,CACL,oBAAAD,EACA,yBAAAC,CACF,CACF,CAEA,OAAO,wBACLC,EACAC,EACAC,EACAC,EACAC,EACoB,CACpB,IAAIC,EAAeL,EAAc,IAAIE,CAAgB,EAAE,IAAID,CAAa,EACpEK,EAAeN,EAAc,IAAIG,CAAgB,EAAE,IAAIF,CAAa,EAExE,GAAIG,IAAmB,EACrB,MAAO,CAAE,aAAAC,EAAc,aAAAC,CAAa,EAC/B,GAAIF,IAAmB,EAG5B,OAFwBvB,EAAWmB,EAAc,IAAIE,CAAgB,EAAGD,CAAa,EAEjE,GAAGb,CAAI,GAAKiB,EAAa,GAAGjB,CAAI,IAClDiB,EAAeA,EAAa,IAAI,IAAIhB,EAAG,CAAC,CAAC,GAGnBR,EAAWmB,EAAc,IAAIG,CAAgB,EAAGF,CAAa,EAEjE,GAAGb,CAAI,GAAKkB,EAAa,GAAGlB,CAAI,IAClDkB,EAAeA,EAAa,IAAI,IAAIjB,EAAG,CAAC,CAAC,GAGpC,CAAE,aAAAgB,EAAc,aAAAC,CAAa,EAEtC,MAAM,MAAM,4BAA4B,CAC1C,CACF","names":["BN","BN","FEE_RATE_DENOMINATOR_VALUE","checkedRem","dividend","divisor","checkedCeilDiv","rhs","quotient","remainder","ZERO","BN","ConstantProductCurve","sourceAmount","swapSourceAmount","swapDestinationAmount","invariant","newSwapSourceAmount","newSwapDestinationAmount","_newSwapSourceAmount","sourceAmountSwapped","destinationAmountSwapped","lpTokenAmount","lpTokenSupply","swapTokenAmount0","swapTokenAmount1","roundDirection","tokenAmount0","tokenAmount1"]}